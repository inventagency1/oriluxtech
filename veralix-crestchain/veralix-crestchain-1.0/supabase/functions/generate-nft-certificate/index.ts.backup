import { serve } from "https://deno.land/std@0.168.0/http/server.ts"
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.7.1'
import { qrcode } from "https://deno.land/x/qrcode@v2.0.0/mod.ts"
import { createHTMLTemplate, type CertificateData } from './template.ts'

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

// Pinata configuration
const PINATA_JWT = Deno.env.get('PINATA_JWT')

// M√∫ltiples gateways IPFS para almacenar en BD
const IPFS_GATEWAYS = [
  'https://gateway.pinata.cloud/ipfs/',
  'https://ipfs.io/ipfs/',
  'https://cloudflare-ipfs.com/ipfs/',
  'https://dweb.link/ipfs/',
  'https://w3s.link/ipfs/'
];
const DEFAULT_BLOCKCHAIN_NAME = Deno.env.get('PUBLIC_BLOCKCHAIN_NAME') || 'Crestchain'

// Helper function to upload JSON to Pinata IPFS with retry logic
async function uploadJSONToPinata(data: any, filename: string, maxRetries = 3): Promise<string> {
  let lastError: Error | null = null;
  
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      console.log(`üì§ [Intento ${attempt}/${maxRetries}] Subiendo JSON a Pinata: ${filename}`);
      
      const response = await fetch('https://api.pinata.cloud/pinning/pinJSONToIPFS', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${PINATA_JWT}`
        },
        body: JSON.stringify({
          pinataContent: data,
          pinataMetadata: {
            name: filename,
            keyvalues: {
              type: 'nft-metadata',
              platform: 'veralix'
            }
          }
        })
      });

      if (!response.ok) {
        const errorData = await response.text();
        console.error(`‚ùå [Intento ${attempt}] Error de Pinata:`, errorData);
        throw new Error(`Failed to upload to Pinata: ${response.status} ${response.statusText}`);
      }

      const result = await response.json();
      const ipfsHash = result.IpfsHash;
      
      console.log(`‚úÖ JSON subido exitosamente: ${ipfsHash}`);
      return `ipfs://${ipfsHash}`;
    } catch (error) {
      lastError = error as Error;
      console.error(`‚ùå [Intento ${attempt}/${maxRetries}] Error subiendo JSON:`, error);
      
      if (attempt < maxRetries) {
        const waitTime = attempt * 2000;
        console.log(`‚è≥ Esperando ${waitTime}ms antes de reintentar...`);
        await new Promise(resolve => setTimeout(resolve, waitTime));
      }
    }
  }
  
  throw new Error(`Failed to upload JSON after ${maxRetries} attempts: ${lastError?.message}`);
}

// Helper function to upload file to Pinata IPFS with retry logic
async function uploadFileToPinata(fileBlob: Blob, filename: string, maxRetries = 3): Promise<string> {
  let lastError: Error | null = null;
  
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      console.log(`üì§ [Intento ${attempt}/${maxRetries}] Subiendo archivo a Pinata: ${filename}`);
      
      const formData = new FormData();
      formData.append('file', fileBlob, filename);
      formData.append('pinataMetadata', JSON.stringify({
        name: filename,
        keyvalues: {
          type: filename.endsWith('.pdf') ? 'certificate-pdf' : 'jewelry-image',
          platform: 'veralix'
        }
      }));

      const response = await fetch('https://api.pinata.cloud/pinning/pinFileToIPFS', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${PINATA_JWT}`
        },
        body: formData
      });

      if (!response.ok) {
        const errorData = await response.text();
        console.error(`‚ùå [Intento ${attempt}] Error de Pinata:`, errorData);
        throw new Error(`Failed to upload file to Pinata: ${response.status}`);
      }

      const result = await response.json();
      const ipfsHash = result.IpfsHash;
      
      console.log(`‚úÖ Archivo subido exitosamente: ${ipfsHash}`);
      return `ipfs://${ipfsHash}`;
    } catch (error) {
      lastError = error as Error;
      console.error(`‚ùå [Intento ${attempt}/${maxRetries}] Error subiendo archivo:`, error);
      
      if (attempt < maxRetries) {
        const waitTime = attempt * 2000;
        await new Promise(resolve => setTimeout(resolve, waitTime));
      }
    }
  }
  
  throw new Error(`Failed to upload file after ${maxRetries} attempts: ${lastError?.message}`);
}

// Helper function to generate social media image using Lovable AI
async function generateSocialImage(
  jewelryName: string,
  certificateId: string
): Promise<string | null> {
  try {
    console.log('üé® Generando imagen social con Lovable AI...');
    
    const LOVABLE_API_KEY = Deno.env.get('LOVABLE_API_KEY');
    if (!LOVABLE_API_KEY) {
      console.warn('‚ö†Ô∏è LOVABLE_API_KEY no configurado');
      return null;
    }

    const prompt = `Create a premium luxury certificate social media image for "${jewelryName}" (ID: ${certificateId}). 
    Design requirements:
    - Elegant gold and black color scheme
    - "VERALIX CERTIFIED" as main text
    - Certificate ID "${certificateId}" prominently displayed
    - Luxury jewelry theme with ornamental borders
    - Professional and prestigious appearance
    - Suitable for social media sharing (1200x630px)`;

    const response = await fetch('https://ai.gateway.lovable.dev/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${LOVABLE_API_KEY}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'google/gemini-2.5-flash-image-preview',
        messages: [{ role: 'user', content: prompt }],
        modalities: ['image', 'text']
      })
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('‚ùå Error de Lovable AI:', errorText);
      return null;
    }

    const data = await response.json();
    const imageBase64 = data.choices?.[0]?.message?.images?.[0]?.image_url?.url;

    if (!imageBase64) {
      console.warn('‚ö†Ô∏è No se recibi√≥ imagen de Lovable AI');
      return null;
    }

    const base64Data = imageBase64.replace(/^data:image\/\w+;base64,/, '');
    const binaryData = Uint8Array.from(atob(base64Data), c => c.charCodeAt(0));
    const imageBlob = new Blob([binaryData], { type: 'image/png' });

    console.log('üì§ Subiendo imagen social a IPFS...');
    const socialImageUri = await uploadFileToPinata(imageBlob, `${certificateId}-social.png`);

    console.log('‚úÖ Imagen social generada y subida:', socialImageUri);
    return socialImageUri;
    
  } catch (error) {
    console.error('‚ùå Error generando imagen social:', error);
    return null;
  }
}

// Helper function to format currency values
function formatCurrency(amount: number, currency: string): string | null {
  if (!amount) return null;
  
  const formatted = new Intl.NumberFormat('es-CO', {
    style: 'currency',
    currency: currency === 'COP' ? 'COP' : 'USD',
    minimumFractionDigits: 0,
    maximumFractionDigits: 0
  }).format(amount);
  
  return formatted;
}

// Helper function to sanitize and validate description
function sanitizeDescription(description: string | null): string {
  if (!description) return 'Sin descripci√≥n';
  
  if (description.length < 10) return 'Sin descripci√≥n';
  
  const hasVowels = /[aeiou√°√©√≠√≥√∫]/gi.test(description);
  const hasSpaces = description.includes(' ');
  
  if (!hasVowels && !hasSpaces) return 'Sin descripci√≥n';
  
  if (description.length > 200) {
    return description.substring(0, 197) + '...';
  }
  
  return description;
}

// ‚úÖ FIX: Helper function to get jewelry image from storage with chunk-based base64 conversion
async function getImageFromStorage(
  supabase: any,
  jewelryItemId: string,
  userId: string
): Promise<string | null> {
  console.log(`üñºÔ∏è Buscando imagen para jewelry_id: ${jewelryItemId}, user_id: ${userId}`);
  
  // PRIORITY 1: Intentar con main_image_url de la DB
  try {
    const { data: jewelryData, error: jewelryError } = await supabase
      .from('jewelry_items')
      .select('main_image_url')
      .eq('id', jewelryItemId)
      .single();
    
    if (!jewelryError && jewelryData?.main_image_url) {
      console.log('‚úÖ Found main_image_url:', jewelryData.main_image_url);
      
      // Extraer path del storage URL
      const urlParts = jewelryData.main_image_url.split('/jewelry-images/');
      if (urlParts.length === 2) {
        const path = urlParts[1];
        console.log('üîç Downloading from path:', path);
        
        const { data, error } = await supabase.storage
          .from('jewelry-images')
          .download(path);
        
        if (!error && data) {
          console.log('‚úÖ Downloaded image from main_image_url');
          
          // ‚úÖ FIX: Conversi√≥n base64 con chunks para evitar stack overflow
          const arrayBuffer = await data.arrayBuffer();
          const bytes = new Uint8Array(arrayBuffer);
          
          let binary = '';
          const chunkSize = 8192; // 8KB chunks
          for (let i = 0; i < bytes.length; i += chunkSize) {
            const chunk = bytes.subarray(i, Math.min(i + chunkSize, bytes.length));
            binary += String.fromCharCode.apply(null, Array.from(chunk));
          }
          
          const base64 = btoa(binary);
          console.log(`‚úÖ Image converted to base64 (${base64.length} chars)`);
          return `data:image/jpeg;base64,${base64}`;
        }
      }
    }
  } catch (e) {
    console.warn('‚ö†Ô∏è Error checking main_image_url:', e);
  }
  
  // PRIORITY 2: Fallback a nombres comunes
  const possibleNames = ['main.jpg', 'main.png', 'main.jpeg', 'image-0.jpg', 'image-0.png'];
  
  for (const fileName of possibleNames) {
    try {
      console.log(`üîç Intentando: ${userId}/${jewelryItemId}/${fileName}`);
      const { data, error } = await supabase.storage
        .from('jewelry-images')
        .download(`${userId}/${jewelryItemId}/${fileName}`)

      if (!error && data) {
        console.log(`‚úÖ Found image: ${fileName}`)
        
        // ‚úÖ FIX: Conversi√≥n base64 con chunks
        const arrayBuffer = await data.arrayBuffer();
        const bytes = new Uint8Array(arrayBuffer);
        
        let binary = '';
        const chunkSize = 8192;
        for (let i = 0; i < bytes.length; i += chunkSize) {
          const chunk = bytes.subarray(i, Math.min(i + chunkSize, bytes.length));
          binary += String.fromCharCode.apply(null, Array.from(chunk));
        }
        
        const base64 = btoa(binary);
        console.log(`‚úÖ Image converted to base64 (${base64.length} chars)`);
        return `data:image/jpeg;base64,${base64}`;
      }
    } catch (e) {
      console.log(`‚ùå No encontrado: ${fileName}`);
      continue
    }
  }
  
  console.log('‚ö†Ô∏è No image found in storage after all attempts')
  return null
}

// Helper function to generate QR code
async function generateQRCode(url: string): Promise<string> {
  try {
    console.log('üî≤ Generando QR code para:', url);
    
    // La librer√≠a de Deno retorna directamente base64
    const qrBase64 = await qrcode(url, {
      size: 400,
    });
    
    console.log('‚úÖ QR code generado exitosamente');
    return qrBase64; // Ya viene en formato data:image/gif;base64,...
    
  } catch (error) {
    console.error('‚ùå Error generando QR code:', error);
    throw error;
  }
}

// ============= ORILUXCHAIN INTEGRATION =============

interface OriluxchainPayload {
  event: 'jewelry_certified';
  payload: {
    certificate_id: string;
    jewelry_type: string;
    material: string;
    weight: string;
    stones: Array<{
      type: string;
      carats: number;
      clarity: string;
      color: string;
    }>;
    jeweler: {
      name: string;
      location: string;
      license: string;
    };
    owner: {
      wallet_address: string;
      name: string;
    };
    nft: {
      token_id: string;
      contract_address: string;
      metadata_uri: string;
    };
    images: string[];
    metadata: {
      appraisal_value: string;
      certification_date: string;
    };
  };
}

interface OriluxchainResponse {
  success: boolean;
  message: string;
  certificate_id: string;
  blockchain: {
    hash: string;
    status: 'pending_mining' | 'verified';
    pending_block: number;
  };
  verification_url: string;
}

async function registerInOriluxchain(
  supabaseAdmin: any,
  certificateId: string,
  certificateUUID: string,
  jewelryData: any,
  userId: string,
  metadataUri: string,
  tokenId: string,
  contractAddress: string,
  jewelryImageUri: string | null
): Promise<OriluxchainResponse | null> {
  
  try {
    console.log('üîó Registrando certificado en Oriluxchain...');

    // Obtener datos del usuario/joyero
    const { data: userData } = await supabaseAdmin
      .from('profiles')
      .select('full_name, business_name, city, country, wallet_address')
      .eq('user_id', userId)
      .single();

    // Mapear materiales a string
    const materials = (jewelryData.materials || []).join(', ') || 'No especificado';
    
    // Construir payload para Oriluxchain
    const payload: OriluxchainPayload = {
      event: 'jewelry_certified',
      payload: {
        certificate_id: certificateId,
        jewelry_type: jewelryData.type || 'jewelry',
        material: materials,
        weight: jewelryData.weight ? `${jewelryData.weight}g` : 'N/A',
        
        // Stones (si existen en el futuro)
        stones: jewelryData.stones || [],
        
        // Jeweler info
        jeweler: {
          name: userData?.business_name || userData?.full_name || 'Joyero Veralix',
          location: userData?.city && userData?.country 
            ? `${userData.city}, ${userData.country}` 
            : 'Colombia',
          license: jewelryData.jeweler_license || 'VRX-CERTIFIED'
        },
        
        // Owner info
        owner: {
          wallet_address: userData?.wallet_address || '0x0000000000000000000000000000000000000000',
          name: userData?.full_name || 'Propietario Veralix'
        },
        
        // NFT info
        nft: {
          token_id: tokenId,
          contract_address: contractAddress,
          metadata_uri: metadataUri
        },
        
        // Images
        images: jewelryImageUri ? [`https://ipfs.io/ipfs/${jewelryImageUri.replace('ipfs://', '')}`] : [],
        
        // Metadata
        metadata: {
          appraisal_value: jewelryData.sale_price 
            ? `${jewelryData.sale_price} ${jewelryData.currency || 'COP'}` 
            : 'No evaluado',
          certification_date: new Date().toISOString().split('T')[0]
        }
      }
    };

    console.log('üì§ Enviando a Oriluxchain:', JSON.stringify(payload, null, 2));

    // Llamar a Oriluxchain
    const ORILUX_API_URL = Deno.env.get('ORILUXCHAIN_API_URL') || 'http://host.docker.internal:5000/api/veralix/webhook';
    console.log(`üì§ Enviando request a Oriluxchain en: ${ORILUX_API_URL}`);

    const response = await fetch(ORILUX_API_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Blockchain': 'Oriluxchain'
      },
      body: JSON.stringify(payload)
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('‚ùå Oriluxchain error:', response.status, errorText);
      throw new Error(`Oriluxchain API error: ${response.status}`);
    }

    const blockchainData: OriluxchainResponse = await response.json();
    console.log('‚úÖ Respuesta de Oriluxchain:', blockchainData);

    // Actualizar certificado con datos de Oriluxchain
    const { error: updateError } = await supabaseAdmin
      .from('nft_certificates')
      .update({
        orilux_blockchain_hash: blockchainData.blockchain.hash,
        orilux_blockchain_status: 'pending',
        orilux_verification_url: blockchainData.verification_url,
        orilux_block_number: blockchainData.blockchain.pending_block,
        orilux_tx_hash: blockchainData.blockchain.hash,
        orilux_timestamp: Date.now()
      })
      .eq('id', certificateUUID);

    if (updateError) {
      console.error('‚ö†Ô∏è Error actualizando certificado con datos Orilux:', updateError);
    } else {
      console.log('‚úÖ Certificado actualizado con datos de Oriluxchain');
    }

    // Log de auditor√≠a
    await supabaseAdmin.rpc('log_audit_action', {
      _action: 'oriluxchain_registration',
      _resource_type: 'nft_certificate',
      _resource_id: certificateId,
      _details: {
        blockchain_hash: blockchainData.blockchain.hash,
        verification_url: blockchainData.verification_url,
        status: 'pending'
      }
    });

    return blockchainData;

  } catch (error: any) {
    console.error('‚ùå Error registrando en Oriluxchain:', error.message);
    
    // Log del error pero NO FALLAR la generaci√≥n del certificado
    await supabaseAdmin.rpc('log_audit_action', {
      _action: 'oriluxchain_registration_failed',
      _resource_type: 'nft_certificate',
      _resource_id: certificateId,
      _details: {
        error: error.message,
        timestamp: new Date().toISOString()
      }
    });

    return null;
  }
}

// Main function to generate certificate HTML (no PDF generation in Edge Functions)
async function generateCertificateHTML(
  jewelryData: any,
  certificateId: string,
  verificationUrl: string,
  transactionHash: string,
  blockNumber: string,
  tokenId: string,
  supabase: any
): Promise<{ blob: Blob; html: string }> {
  console.log('üìÑ Generando certificado HTML...');
  
  // 1. Obtener imagen de joya
  const jewelryImageBase64 = await getImageFromStorage(supabase, jewelryData.id, jewelryData.user_id);
  if (jewelryImageBase64) {
    console.log('‚úÖ Imagen de joya cargada correctamente');
  } else {
    console.warn('‚ö†Ô∏è No se pudo cargar la imagen de joya');
  }
  
  // 2. Generar QR code
  const qrCodeBase64 = await generateQRCode(verificationUrl);
  
  // 3. Preparar datos para el template
  const certificateData: CertificateData = {
    certificateId,
    jewelryName: jewelryData.name,
    jewelryType: jewelryData.type,
    materials: jewelryData.materials || [],
    weight: jewelryData.weight ? `${jewelryData.weight}g` : null,
    origin: jewelryData.origin,
    artisan: jewelryData.craftsman,
    description: sanitizeDescription(jewelryData.description),
    value: formatCurrency(jewelryData.sale_price, jewelryData.currency),
    date: new Date().toLocaleDateString('es-ES', { 
      year: 'numeric', 
      month: 'long', 
      day: 'numeric' 
    }),
    jewelryImage: jewelryImageBase64,
    qrCode: qrCodeBase64,
    transactionHash,
    blockNumber,
    blockchainNetwork: DEFAULT_BLOCKCHAIN_NAME,
    tokenId
  };
  
  // 4. Crear HTML desde template
  const certificateHTML = createHTMLTemplate(certificateData);
  
  console.log('‚úÖ HTML del certificado generado exitosamente');
  
  // 5. Retornar HTML como Blob y tambi√©n el texto para cach√©
  const htmlBlob = new Blob([certificateHTML], { type: 'text/html' });
  return { blob: htmlBlob, html: certificateHTML };
}

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders })
  }

  try {
    console.log('üöÄ Iniciando generaci√≥n de certificado NFT...')
    
    const supabaseAdmin = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    )

    const { jewelryItemId, userId } = await req.json()
    console.log('üìù Datos recibidos:', { jewelryItemId, userId })

    // Get jewelry item details
    const { data: jewelryData, error: jewelryError } = await supabaseAdmin
      .from('jewelry_items')
      .select('*')
      .eq('id', jewelryItemId)
      .single()

    if (jewelryError || !jewelryData) {
      throw new Error('Jewelry item not found')
    }

    console.log('‚úÖ Jewelry item obtenido:', jewelryData.name)

    // Generate unique certificate ID
    const { data: certIdData } = await supabaseAdmin.rpc('generate_certificate_id')
    const certificateId = certIdData || `VRX-${Date.now()}`
    console.log('üÜî Certificate ID generado:', certificateId)

    // Generate blockchain data (MVP simulation)
    const transactionHash = `0x${Array.from({ length: 64 }, () => 
      Math.floor(Math.random() * 16).toString(16)
    ).join('')}`
    const blockNumber = Math.floor(Math.random() * 1000000).toString()
    const tokenId = Math.floor(Math.random() * 1000000).toString()
    const contractAddress = '0x742d35Cc6634C0532925a3b844Bc454e4438f44e'

    console.log('üîó Blockchain data (MVP):', { transactionHash, blockNumber, tokenId })

    // Upload jewelry images to IPFS
    console.log('üì§ Subiendo im√°genes de joyer√≠a a IPFS...')
    const jewelryImageBase64 = await getImageFromStorage(supabaseAdmin, jewelryItemId, userId)
    let jewelryImageUri = null
    
    if (jewelryImageBase64) {
      const base64Data = jewelryImageBase64.replace(/^data:image\/\w+;base64,/, '')
      const binaryData = Uint8Array.from(atob(base64Data), c => c.charCodeAt(0))
      const imageBlob = new Blob([binaryData], { type: 'image/jpeg' })
      jewelryImageUri = await uploadFileToPinata(imageBlob, `${certificateId}-jewelry.jpg`)
      console.log('‚úÖ Imagen de joyer√≠a subida a IPFS')
    }

    // Create metadata
    const BASE_URL = Deno.env.get('PUBLIC_BASE_URL') || Deno.env.get('APP_BASE_URL') || 'http://localhost:8082'
    const verificationUrl = `${BASE_URL}/verify/${certificateId}`
    
    const metadata = {
      name: `${jewelryData.name} - Certificado Veralix`,
      description: `Certificado de autenticidad NFT para ${jewelryData.name}. ${sanitizeDescription(jewelryData.description)}`,
      image: jewelryImageUri || 'ipfs://QmDefault',
      external_url: verificationUrl,
      attributes: [
        { trait_type: 'Tipo', value: jewelryData.type },
        { trait_type: 'Materiales', value: (jewelryData.materials || []).join(', ') },
        { trait_type: 'Peso', value: jewelryData.weight ? `${jewelryData.weight}g` : 'N/A' },
        { trait_type: 'Origen', value: jewelryData.origin || 'N/A' },
        { trait_type: 'Artesano', value: jewelryData.craftsman || 'N/A' },
        { trait_type: 'Certificado ID', value: certificateId },
        { trait_type: 'Blockchain', value: DEFAULT_BLOCKCHAIN_NAME },
        { trait_type: 'Network', value: 'Mainnet' }
      ],
      properties: {
        certificateId,
        transactionHash,
        blockNumber,
        tokenId,
        contractAddress,
        verificationUrl
      }
    }

    // Upload metadata to IPFS
    console.log('üì§ Subiendo metadata a IPFS...')
    const metadataUri = await uploadJSONToPinata(metadata, `${certificateId}-metadata.json`)
    console.log('‚úÖ Metadata subida:', metadataUri)

    // Generate certificate HTML
    console.log('üìÑ Generando HTML del certificado...')
    const { blob: htmlBlob, html: certificateHTMLContent } = await generateCertificateHTML(
      jewelryData,
      certificateId,
      verificationUrl,
      transactionHash,
      blockNumber,
      tokenId,
      supabaseAdmin
    )
    
    // Upload HTML to Pinata IPFS for proper rendering
    console.log('üì§ Subiendo HTML del certificado a IPFS...')
    const certificateHtmlUri = await uploadFileToPinata(htmlBlob, `${certificateId}.html`)
    console.log('‚úÖ HTML del certificado subido a IPFS:', certificateHtmlUri)

    // Generate social image
    const socialImageUri = await generateSocialImage(jewelryData.name, certificateId)

    // Create certificate record in database
    const { data: certificateRecord, error: certError } = await supabaseAdmin
      .from('nft_certificates')
      .insert({
        id: crypto.randomUUID(),
        certificate_id: certificateId,
        jewelry_item_id: jewelryItemId,
        user_id: userId,
        owner_id: userId,
        transaction_hash: transactionHash,
        token_id: tokenId,
        contract_address: contractAddress,
        block_number: blockNumber,
        metadata_uri: metadataUri,
        certificate_pdf_url: certificateHtmlUri,
        qr_code_url: await generateQRCode(verificationUrl),
        social_image_url: socialImageUri,
        verification_url: verificationUrl,
        certificate_view_url: verificationUrl,
        blockchain_verification_url: `https://scan.crestchain.pro/tx/${transactionHash}`,
        is_verified: true,
        blockchain_network: 'crestchain',
        verification_date: new Date().toISOString()
      })
      .select()
      .single()

    if (certError) {
      console.error('‚ùå Error creando registro de certificado:', certError)
      throw certError
    }

    // Cachear el HTML generado para acceso r√°pido (10x m√°s r√°pido)
    try {
      console.log('üíæ Cacheando HTML del certificado...')
      const { error: cacheError } = await supabaseAdmin
        .from('certificate_cache')
        .insert({
          certificate_id: certificateId,
          html_content: certificateHTMLContent,
          ipfs_hash: certificateHtmlUri.replace('ipfs://', '')
        })
      
      if (cacheError) {
        console.warn('‚ö†Ô∏è No se pudo cachear certificado:', cacheError)
        // No fallar la generaci√≥n por esto
      } else {
        console.log('‚úÖ Certificado cacheado exitosamente - futuras cargas ser√°n 10x m√°s r√°pidas')
      }
    } catch (cacheErr) {
      console.warn('‚ö†Ô∏è Error al cachear:', cacheErr)
      // Continuar sin fallar
    }

    // Update jewelry item status
    await supabaseAdmin
      .from('jewelry_items')
      .update({ status: 'certified' })
      .eq('id', jewelryItemId)

    // Log audit
    await supabaseAdmin.rpc('log_audit_action', {
      _action: 'certificate_generated',
      _resource_type: 'nft_certificate',
      _resource_id: certificateId,
      _details: {
        jewelry_item_id: jewelryItemId,
        certificate_id: certificateId,
        transaction_hash: transactionHash,
        metadata_uri: metadataUri
      }
    })

    // ============= REGISTRO EN ORILUXCHAIN (BACKGROUND) =============
    // Usar EdgeRuntime.waitUntil para ejecutar en background sin bloquear la respuesta
    if (typeof EdgeRuntime !== 'undefined' && (EdgeRuntime as any).waitUntil) {
      (EdgeRuntime as any).waitUntil(
        registerInOriluxchain(
          supabaseAdmin,
          certificateId,
          certificateRecord.id,
          jewelryData,
          userId,
          metadataUri,
          tokenId,
          contractAddress,
          jewelryImageUri
        ).then((oriluxResult) => {
          if (oriluxResult) {
            console.log('‚úÖ Oriluxchain registration completed:', oriluxResult.verification_url);
          } else {
            console.log('‚ö†Ô∏è Oriluxchain registration failed, but certificate created successfully');
          }
        })
      );
    } else {
      // Fallback: Ejecutar de forma as√≠ncrona sin bloquear (en desarrollo)
      registerInOriluxchain(
        supabaseAdmin,
        certificateId,
        certificateRecord.id,
        jewelryData,
        userId,
        metadataUri,
        tokenId,
        contractAddress,
        jewelryImageUri
      ).catch(err => {
        console.warn('‚ö†Ô∏è Oriluxchain registration failed:', err.message);
      });
    }

    console.log('‚úÖ Certificado generado exitosamente')

    return new Response(
      JSON.stringify({
        success: true,
        message: 'Certificate generated successfully',
        certificate: {
          id: certificateRecord.id,
          certificateId,
          transactionHash,
          tokenId,
          metadataUri,
          certificateViewUrl: verificationUrl,
          blockchainVerificationUrl: `https://scan.crestchain.pro/tx/${transactionHash}`,
          verificationUrl,
          qrCodeUrl: certificateRecord.qr_code_url,
          htmlUrl: certificateHtmlUri
        }
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 200
      }
    )

  } catch (error: any) {
    console.error('‚ùå Error generando certificado:', error)
    return new Response(
      JSON.stringify({
        success: false,
        error: error.message,
        message: 'Failed to generate certificate'
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 500
      }
    )
  }
})
